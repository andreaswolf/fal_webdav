<?php
namespace TYPO3\FalWebdav\Dav;

/**
 * This file is part of the TYPO3 CMS project.
 *
 * It is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License, either version 2
 * of the License, or any later version.
 *
 * For the full copyright and license information, please read the
 * LICENSE.txt file that was distributed with this source code.
 *
 * The TYPO3 project - inspiring people to share!
 */

include_once __DIR__ . '/../../Resources/Composer/vendor/autoload.php';

use Sabre\DAV\Client;
use Sabre\HTTP;


/**
 * Helper class to circumvent limitations in SabreDAV's support for cURL's certificate verification options.
 */
class WebDavClient extends Client {

	/**
	 * Trigger to enable/disable peer certificate verification
	 *
	 * @var boolean
	 */
	protected $verifyCertificates = TRUE;

	/**
	 * The file to write the data to.
	 *
	 * @var resource
	 */
	protected $outputFile = NULL;


	/**
	 * @param boolean $peerVerification
	 */
	public function setCertificateVerification($peerVerification) {
		$this->verifyCertificates = $peerVerification;
	}

	/**
	 * Wrapper for all cUrl functions.
	 *
	 * @param resource $curlHandle
	 *
	 * @return array
	 */
	protected function curlExec($curlHandle) {
		if ($this->verifyCertificates === FALSE) {
			curl_setopt($curlHandle, CURLOPT_SSL_VERIFYPEER, FALSE);
		}
		if ($this->outputFile !== NULL) {
			// make sure the file is never returned into the default output stream
			curl_setopt($curlHandle, CURLOPT_RETURNTRANSFER, FALSE);
			// don’t return the headers
			curl_setopt($curlHandle, CURLOPT_HEADER, FALSE);
			curl_setopt($curlHandle, CURLOPT_FILE, $this->outputFile);
			curl_setopt($curlHandle, CURLOPT_FOLLOWLOCATION, TRUE);
			$this->outputFile = NULL;
		} else {
			// set back to default as the cURL handle is not always reset; the file is not used anyways, but cURL
			// still complains about the handle being gone away if we closed the file that was used in an earlier
			// request
			curl_setopt($curlHandle, CURLOPT_FILE, fopen('php://stdout','w'));

			// we must use a different order here; setting RETURNTRANSFER before resetting the file handle will let
			// cURL still use the file.
			curl_setopt($curlHandle, CURLOPT_RETURNTRANSFER, TRUE);
		}

		return parent::curlExec($curlHandle);
	}

	function propFind($url, array $properties = NULL, $depth = 0) {
		if ($properties === NULL) {
			$properties = array(
				'{DAV:}resourcetype',
				'{DAV:}creationdate',
				'{DAV:}getcontentlength',
				'{DAV:}getlastmodified'
			);
		}
		return parent::propFind($url, $properties, $depth); // TODO: Change the autogenerated stub
	}

	/**
	 * Reads the given URL’s contents to the given file handle. The handle must be writable, the disk must have enough
	 * free space and
	 *
	 * @param string $url
	 * @param resource $fileHandle
	 * @param array $headers
	 * @return HTTP\ResponseInterface
	 */
	public function readUrlToHandle($url, $fileHandle, array $headers = []) {
		if (!is_resource($fileHandle)) {
			throw new \InvalidArgumentException('The file handle must be a valid resource');
		}
		$request = new HTTP\Request('GET', $url, $headers);

		// The actual option is set in curlExec(), as we don’t have access to the cURL handle here
		$this->outputFile = $fileHandle;

		return $this->send($request);
	}

}

?>